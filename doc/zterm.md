# ZTerm客户端和服务器的通讯协议规范

本文档规定了ZTerm客户端和服务器之间的通讯规范，本规范的目前版本是1.1。 ZTerm客户端和服务器之间通过HTTPS协议进行通讯。
通讯双方的数据包统一为UTF8编码格式的文本，其中第一个字节表示该数据包的类型，目前支持x类型、p类型、k类型和c类型四种消息包格式。如果第一个字节是小写的x，表示后面的数据包是用户的提问信息，我们称之为"普通消息包"。如果第一个字节是小写的p，表示是检测网络状态的数据包，我们称之为”ping包“。如果第一个字节是小写的k，则是客户端和服务器之间交换密钥的消息包。 如果第一个字母是小写的c，则表示交换的是文档是否有拷贝权利的消息包。

任何类型的消息包，最小长度为150字节。在消息包开始的150字节中，第一个字节以外的149个字节，必须是0-9和小写的a-f组成。

## 客户端发往服务器的数据包格式

### 普通消息包

客户端发往服务器的普通消息包的数据格式如下图所示：

![](x0007.svg)

上述消息包的数据格式分为不同的“域”，这些域从左到右，其具体的含义解释如下：
- 第一个字节为消息包类型。对于普通消息包，该字节恒定为小写的x。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示客户端的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域为用户的公钥，共66个字节，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。 
- 第三个域为一64字节的随机数，表示某个用户和服务器之间的会话(session)的ID。它由数字0-9和小写字母a-f表示，形式类似："fbe788e3aeaeb04ace43dad9bf776cb5cc7d01ee230bdc7ed0bf197ed28ebbc8"。 该随机数由客户端随机产生。服务器根据此信息来判断一系列问话是否属于同一个会话。
- 第四个域是8字节的序列号，由数字0-9和小写字母a-f表示一个4字节的无符号整型值。 该值大的提问在小值的后面。
- 第五个域是8字节，其含义保留，目前固定为“00000000”。
- 第六个域是用户的提问信息，长度可变。
- 第七个域是用户的屏幕信息，长度可变。该域是可选的，并不一定存在。该域的头4个字节是三个连续的双引号(")和一个换行符号(\n)。最后四个字节是一个换行符号(\n)和三个连续的双引号(")。根据这8个字节可以界定屏幕信息。


### Ping类型的数据包格式

客户端每隔30秒会向服务器发送一个特殊的包，来检测服务器是否能够正常连接，我们称之为ping包。如果数据包的第一个字节是小写的p，表示该数据包是ping包，它的数据格式如下图所示：

![](x0008.svg)

Ping包的长度是150个字节，包括第一个字节为小写的p，和其后的66个字节表示用户的公钥。紧随公钥的是80字节的随机数R。R由数字0-9和小写字母a-f来表示。

服务器回复给客户端的ping包格式同上图。当服务器收到来自客户端的ping包后，只需要把其中的R的字节顺序翻转，其余字节保持不变。 所谓字节顺序翻转，指的是最后一个字符变成第一个，第一个字符变成最后一个。例如，字符串"abcdefg"的字节顺序翻转后为"gfedcba"。客户端收到来自服务器的150字节的响应ping包后，和自己之前发送的ping包进行对比，即可确认服务器是否正常工作。


## 服务器发往客户端的数据包格式

服务器发往客户端的消息包的数据格式如下图所示：

![](x0009.svg)

上述消息包的数据格式分为不同的“域”，这些域从左到右，其具体的含义解释如下：
- 第一个字节为消息包类型。对于普通消息包，该字节恒定为小写的x。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示服务器的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域是66字节，该域为用户的公钥，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。
- 第三个域是66字节，该域为服务器的公钥，由数字0-9和小写字母a-f表示。形式类似："0267e45777b1e209cb04937b316e59f4d1a0f5bdd43a1a8489fba702ce9085662b"。 
- 第四个域是14字节，保留。
- 第五个域是可变长度的，包含服务器发给客户端的真正文本信息。

在第五个域中可能包含如下的链接：
```
https://zterm.ai/t/e13b27d2080a9f0d4068ff9a6501b830501a7ee5112f46a7b0e402e95fd841d3
```
这种固定格式的链接，是提供给用户的参考文档，可能是文本，也可能是视频。文档是加密的。

## 专业知识库和视频

为了提高用户的使用体验，服务器返回给用户的信息，除了AI的答复以外，还有后台知识库里的相关内容。 这样的设计把AI和传统的搜索技术优势互补，能够有效弥补AI的不足。在服务器给客户端的回复中，包含两部分的内容：
- 人工智能AI对用户的回复
- 从专业知识库中检索到的相关参考文档。

对于后两者，它们的形式是：
```
https://zterm.ai/t/1bfeb76f5d7022a0edf3845ef9be5549f107f3e30e39f8f6605543ab2293cda8
```

### 客户端向服务器索要解密密钥的数据包格式

当用户想打开一个加密文档时，需要向服务器索要密钥，发送的消息包格式如下：

![](x0011.svg)

上述消息包的数据格式分为不同的“域”，这些域从左到右，其具体的含义解释如下：
- 第一个字节为消息包类型。对于本类型的消息包，该字节恒定为小写的k。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示服务器的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域是66字节，该域为用户的公钥，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。
- 第三个域是文档的编号，64字节，由数字0-9和小写字母a-f表示。
- 第四个域16字节，保留。
 

服务器端收到用户的索要密钥的请求后，根据用户的公钥，在后台数据库中检查该用户是否注册，付费等信息，根据业务规则，决定是否把该文档的密钥发给用户。 回复的消息包格式如下：

![](x0012.svg)

- 第一个字节为消息包类型。对于本类型的消息包，该字节恒定为小写的k。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示服务器的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域是66字节，该域为用户的公钥，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。
- 第三个域是66字节，该域为服务器的公钥，由数字0-9和小写字母a-f表示。形式类似："0267e45777b1e209cb04937b316e59f4d1a0f5bdd43a1a8489fba702ce9085662b"。 
- 第四个域是14字节，保留。
- 第五个域是文档的编号，64字节，由数字0-9和小写字母a-f表示。
- 第六个域是文档的密钥，64字节，由数字0-9和小写字母a-f表示。 如果拒绝提供密钥，该域全部为’0‘，就是64个字符'0'组成。


### 客户端向服务器索要是否有拷贝文本的权利数据包格式 <--- 本功能目前不需要实现，可以跳过。

当客户端的文档阅读器打开文档后，向服务器发送一个查询该文档是否有拷贝文本的权利的消息包，包的格式如下：

![](x0014.svg)

- 第一个域是用户的公钥，66个字节。
- 第二个域是文档的编号，64字节。
- 第三个域16字节，保留。


服务器拿到用户的公钥和文档编号后，根据业务规则，回复消息包如下：

![](x0013.svg)


- 第一个域是用户的公钥，66个字节。
- 第二个域是文档的编号，64字节。
- 第三个域16字节，包含是否允许该文档被拷贝的答复消息，原文是："YES!YES!YES!YES!"。 这个原文被服务器的私钥和客户的公钥加密。
- 第四个域是66字节，包含服务器的公钥。

客户端的逻辑是：如果无法网络连接，或者得到服务器的答复后，第三个域解密后不是"YES!YES!YES!YES!"，则一律不予拷贝的权力。



### 加密文档的格式

加密文档的格式如下图所示：

![](x0010.svg)

加密的文档格式解释如下：
- 第四个字节的低4位比特，表示文件类型。所以一共可以表示16种不同的文件类型，目前支持纯文本的txt类型(其值为0xF)和我们的私有视频格式rdo类型(其值为0xE)。 之所以这样设计，是因为X64平台是小端格式，
- 第一域28比特表示最终文件的尺寸，包括第一、二、三个域的内容。最多可以表示256MB，这足够了。
- 第二个域4字节表示文件的长度，单位是字节，它指的是第四个域的长度。 如果是文本文件，我们采用zlib进行压缩。但是该域记录的是压缩之前原数据的长度。
- 第三个域32字节是第四个域未经压缩的的原始数据的SHA256的哈希值，用于校验文件内容是否损坏。
- 第四个域是可变长度的数据，是真正的文件内容。

第三个域和第四个域的数据采用Chacha20的流加密算法进行加密。加密的密钥K为32字节，单独保存在数据库中。当用户索要加密文档时，K被Kp加密为KK。Kp为32字节，它是由服务器的私钥和用户的公钥计算出来的。Kp加密K的算法是AES256。
```
KK = g(K, Kp)
```

KK和加密后的文档一起发给用户。用户使用其私钥和服务器的公钥计算出Kp，可以解密KK，拿到K。然后用K解密文档。


### Kp的计算问题

客户端和服务器之间的通讯采用https协议，本身是加密的。未来我们发送给客户端的来自服务器的专业知识库中的文本文档和视频是加密的。我们需要把加密的密钥传递给客户端。如果想在应用数据上进一步加密，方法如下。

我们采用比特币内核所使用的secp256k1加密算法。 用户端自行产生自己的私钥S1和公钥P1。服务器端拥有自己的私钥S2和公钥P2。 客户端保存服务器的公钥P2。

私钥S1和S2均是32字节。公钥P1和P2均是33字节。它们之间有如下关系：
```
Kp = f(S1, P2)
Kp = f(S2, P1)
```
其中Kp是32字节。 上述公式表明：由我方私钥和对方公钥可以推导出一个32字节的密钥Kp，该Kp也可以由对方的私钥和我方的公钥计算出来，所以Kp无需在通讯过程中进行传递，从理论上解决了密钥泄露的问题。 双方需要加密的数据均使用K为加密的密钥。



## 建议
任何建议，请发邮件到support@zterm.ai


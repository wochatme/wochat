# ZTerm客户端和服务器的通讯协议规范

本文档规定了ZTerm客户端和服务器之间的通讯规范，本规范的目前版本是1.1。 ZTerm客户端和服务器之间通过HTTPS协议进行通讯。
通讯双方的数据包统一为UTF8编码格式的文本，其中第一个字节表示该数据包的类型，目前支持x类型和p类型两种消息包格式。如果第一个字节是小写的x，表示后面的数据包是用户的提问信息，我们称之为"普通消息包"。如果第一个字节是小写的p，表示是检测网络状态的数据包，我们称之为”ping包“。

任何类型的消息包，最小长度为150字节。在消息包开始的150字节中，第一个字节以外的149个字节，必须是0-9和小写的a-f组成。

## 客户端发往服务器的数据包格式

### 普通消息包

客户端发往服务器的普通消息包的数据格式如下图所示：

![](x0007.svg)

上述消息包的数据格式分为不同的“域”，这些域从左到右，其具体的含义解释如下：
- 第一个字节为消息包类型。对于普通消息包，该字节恒定为小写的x。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示客户端的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域为用户的公钥，共66个字节，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。 
- 第三个域为一64字节的随机数，表示某个用户和服务器之间的会话(session)的ID。它由数字0-9和小写字母a-f表示，形式类似："fbe788e3aeaeb04ace43dad9bf776cb5cc7d01ee230bdc7ed0bf197ed28ebbc8"。 该随机数由客户端随机产生。服务器根据此信息来判断一系列问话是否属于同一个会话。
- 第四个域是8字节的序列号，由数字0-9和小写字母a-f表示一个4字节的无符号整型值。 该值大的提问在小值的后面。
- 第五个域是8字节，其含义保留，目前固定为“00000000”。
- 第六个域是用户的提问信息，长度可变。
- 第七个域是用户的屏幕信息，长度可变。该域是可选的，并不一定存在。该域的头4个字节是三个连续的双引号(")和一个换行符号(\n)。最后四个字节是一个换行符号(\n)和三个连续的双引号(")。根据这8个字节可以界定屏幕信息。


### Ping类型的数据包格式

客户端每隔30秒会向服务器发送一个特殊的包，来检测服务器是否能够正常连接，我们称之为ping包。如果数据包的第一个字节是小写的p，表示该数据包是ping包，它的数据格式如下图所示：

![](x0008.svg)

Ping包的长度是150个字节，包括第一个字节为小写的p，和其后的66个字节表示用户的公钥。紧随公钥的是80字节的随机数R。R由数字0-9和小写字母a-f来表示。

服务器回复给客户端的ping包格式同上图。当服务器收到来自客户端的ping包后，只需要把其中的R的字节顺序翻转，其余字节保持不变。 所谓字节顺序翻转，指的是最后一个字符变成第一个，第一个字符变成最后一个。例如，字符串"abcdefg"的字节顺序翻转后为"gfedcba"。客户端收到来自服务器的150字节的响应ping包后，和自己之前发送的ping包进行对比，即可确认服务器是否正常工作。


## 服务器发往客户端的数据包格式

服务器发往客户端的消息包的数据格式如下图所示：

![](x0009.svg)

上述消息包的数据格式分为不同的“域”，这些域从左到右，其具体的含义解释如下：
- 第一个字节为消息包类型。对于普通消息包，该字节恒定为小写的x。
- 第一个域是紧随消息包类型字节的连续的三个字节，它表示服务器的版本信息，目前固定为"100"，表示是1.0.0版本。
- 第二个域是66字节，该域为用户的公钥，由数字0-9和小写字母a-f表示。形式类似："03339a1c8fdb6aff46845e49d120e0400021e161b6341858585c2e25ca3d9c01ca"。
- 第三个域是66字节，该域为服务器的公钥，由数字0-9和小写字母a-f表示。形式类似："0267e45777b1e209cb04937b316e59f4d1a0f5bdd43a1a8489fba702ce9085662b"。 
- 第四个域是4字节，表示第七个域的真正数据里面包含了多少个加密的文本链接，这个值可能是0，表示没有加密的文档链接。如果这个域是0，第六个域就不存在了。
- 第五个域10个字节，保留。
- 第六个域由0或者多个密钥组成，每个密钥是64字节，由数字0-9和小写字母a-f表示。它表示一个加密文档的密钥。第六个域的密钥个数由第四个域来决定。如果第四个域的值为0，则本域是空。如果第四个域的值是n，则本域包含64 X n个字节。
- 第七个域是可变长度的，包含服务器发给客户端的真正文本信息。

在第七个域中可能包含如下的链接：
```
https://zterm.ai/t/e13b27d2080a9f0d4068ff9a6501b830501a7ee5112f46a7b0e402e95fd841d3
```
这种固定格式的链接，是提供给用户的参考文档，可能是文本，也可能是视频。文档是加密的，加密的密钥由第六个域来记录。

## 专业知识库和视频

为了提高用户的使用体验，服务器返回给用户的信息，除了AI的答复以外，还有后台知识库里的相关内容。 这样的设计把AI和传统的搜索技术优势互补，能够有效弥补AI的不足。在服务器给客户端的回复中，包含三部分的内容：
- 人工智能AI对用户的回复
- 从专业知识库中检索到的相关参考文献，纯文本格式，文件的扩展名为.txt。
- 从专业知识库中检索到的相关视频，文件的扩展名为.rdo。

对于后两者，它们的形式是：
```
https://zterm.ai/t/1bfeb76f5d7022a0edf3845ef9be5549f107f3e30e39f8f6605543ab2293cda8.txt
https://zterm.ai/t/63e2c8fc65155e3a775284305a136fd79ce55203211a00f7e1d0e0fb13128dec.rdo
```

客户端的判断规则是：如果最后三个字符是txt，则表示纯文本的文档；如果是rdo，则表示该链接是我们的私有视频格式。这部分内容的规范未来会出台。


## 加密问题

客户端和服务器之间的通讯采用https协议，本身是加密的。未来我们发送给客户端的来自服务器的专业知识库中的文本文档和视频是加密的。我们需要把加密的密钥传递给客户端。如果想在应用数据上进一步加密，方法如下。

我们采用比特币内核所使用的secp256k1加密算法。 用户端自行产生自己的私钥S1和公钥P1。服务器端拥有自己的私钥S2和公钥P2。 客户端保存服务器的公钥P2。

私钥S1和S2均是32字节。公钥P1和P2均是33字节。它们之间有如下关系：
```
K = f(S1, P2)
K = f(S2, P1)
```
其中K是32字节。 上述公式表明：由我方私钥和对方公钥可以推导出一个32字节的密钥K，该K也可以由对方的私钥和我方的公钥计算出来，所以K无需在通讯过程中进行传递，从理论上解决了密钥泄露的问题。 双方需要加密的数据均使用K为加密的密钥。


## 建议
任何建议，请发邮件到support@zterm.ai


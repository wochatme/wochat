# WoChat的账号体系

WoChat采用比特币内核中的secp256k1的算法进行数据的加密和签名验证。 在secp256k1算法中，私钥Sk是一个32字节的随机数，公钥Pk是由私钥Sk推导出来的，Pk是64字节，经过压缩后，可以变成257bit，就是33个字节，其中第一个字节为0x02或者0x03。后面我们认为Pk统一为33个字节，具体请参考[https://matthewdowney.github.io/compress-bitcoin-public-key.html]

当用Sk对一个32字节的数据Msg进行签名后，得到了一个64字节的签名Sig。别人拿到Msg(32-byte), Sig(64-byte)和你的Pk(33-byte)后，就可以进行验证，确保Msg是经过你的签名的。

WoChat统一采用SHA256算法产生32字节的哈希值(Hash)。 对于真正的通讯数据，WoChat采用Chacha20的流加密算法进行加密。秘钥K是由对方的公钥Pk和我方的私钥Sk共同计算出来的一个32字节的固定值。对方利用他的私钥和我的公钥，也可以轻松计算出K(32-byte)。

WoChat的用户绝大部分是中国人。由于一个汉字在UTF8中为3个字节，而在UTF16中绝大部分都是2个字节，节省了1/3，所以WoChat中字符串统一使用UTF16编码。

## 用户注册

用户选择一个用户名UserName和口令Password。WoChat实际上使用SHA256算法把UserName和Password统一变成了32个字节。所以后面我们可以认为用户名和口令都是32个字节。
注册的过程实际上是私钥Sk和公钥Pk的创建过程。 WoChat首先调用操作系统提供的随机数产生函数，产生一个32个字节的随机数，此即Sk。Pk由Sk产生。 当Sk和Pk成功创建以后，WoChat用口令Password对私钥进行加密，加密算法是AES256，加密后的Sk存放在本地的数据库中，数据库使用SQLite。

用户使用私钥对用户名UserName(32-byte)进行签名，获得了64字节的签名Signature。 当用户连接服务器时，会向服务器提供自己的信息UserInfo(User Information)，包括UserName, Signature和Pk，共计129个字节(32 + 64 + 33)。 服务器拿到这些信息后，进行验证，验证通过后，保存在后台数据库中。当然了，如果以前保存过，就不用再保存了。后台数据库使用LevelDB数据库。 如果服务器发现该用户的用户名和别人的用户名冲突了，可以告诉该用户换一个名字。 名字的最大长度设置为64个字符，128个字节。 WoChat的用户的用户名在全局是唯一的，用户名仅仅是在后台做主键进行索引使用。

## 加好友

用户向服务器提出加好友，用户需要提供好友的用户名FN(Friend Name, 32-byte)。服务器根据FN作为主键，在后台数据库中查找，找到后，即把该好友的公钥Pk发送给用户。如果没有找到，则告诉用户该好友不存在。 用户可以通知其好友完成账号注册后，连接服务器。每次WoChat客户端连接服务器，第一步就是提供UserInfo。所以只要一次连接服务器成功，服务器的数据库中即保存了该用户的公钥。

## 聊天

用户拿到好友的Pk后，最好是通过电话等方式和对方确认一下公钥Pk。由于Pk只有33个字节，所以一方朗读，一方验证，一分钟即可完成。

用户使用自己的Sk和对方的Pk进行计算，得到了一个32字节的V。 对方用自己的私钥Sk和我方的Pk进行计算，也可以得到V。 双方之间的通讯始终采用V(32-byte)做为加密使用密钥。 加密算法使用Chacha20的流加密算法。

## 群聊
一个群(Group)或者一个房间(Room)，拥有自身的Sk和Pk。被或准加入该群的成员均可以访问该群的Sk。往群里发消息使用的密钥VG由己方的Sk和该群的Pk计算出来。 由于群成员均拥有该群的Sk，由该Sk和发送消息者的Pk可以计算出VG，对发往该群的的消息进行解密。


如果某一个成员被提出该群后，因为他曾经拥有该群的Sk，如何根本上防止不再该群中的曾经的老成员查看发往该群的消息呢？？？？

